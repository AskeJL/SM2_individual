/*
 * generated by Xtext 2.25.0
 */
package dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dsl.greenhouse.Model
import org.eclipse.xtext.EcoreUtil2
import dsl.greenhouse.RowSensor
import dsl.greenhouse.RowActuator
import dsl.greenhouse.GreenhouseActuator
import dsl.greenhouse.State
import dsl.greenhouse.Action
import dsl.greenhouse.GreenhouseSensor
import dsl.greenhouse.Greenhouse
import dsl.greenhouse.Row
import dsl.greenhouse.RowRuleSet
import dsl.greenhouse.GreenhouseRuleSet
import dsl.greenhouse.MathNumber
import dsl.greenhouse.Plus
import dsl.greenhouse.Minus
import dsl.greenhouse.Mult
import dsl.greenhouse.Div
import dsl.greenhouse.SettingSensor
import dsl.greenhouse.SettingActuator

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GreenhouseGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val model = resource.allContents.filter(Model).next
		fsa.generateFile('controller/' + model.name + ".java", model.compileController)
		fsa.generateFile('peripheral/' + model.name + ".java", model.compilePeripheral)
		fsa.generateFile('verification/' + model.name + ".xta", model.compileVerification)
		
	}
	
	def compileController(Model model)'''
	from paho.mqtt import client as mqtt_client
	
	broker = 'localhost'
	port = 1883
	topic1 = "temp"
	topic2 = "humidity"
	topic3 = "co2"
	pubTopic = "actuators"
	client_id = 'python-mqtt-rulechecker'
	username = 'my_user'
	password = 'bendevictor'
	
	def connect_mqtt() -> mqtt_client:
	    def on_connect(client, userdata, flags, rc):
	        if rc == 0:
	            print("Connected to MQTT Broker!")
	        else:
	            print("Failed to connect, return code %d\n", rc)
	
	    client = mqtt_client.Client(client_id)
	    client.username_pw_set(username, password)
	    client.on_connect = on_connect
	    client.connect(broker, port)
	    return client
	
	def subscribe(client: mqtt_client, topic):
	    def on_message(client, userdata, msg):
	        print(f"Received `{msg.payload.decode()}` from `{msg.topic}` topic")
	        ruleCheck(msg.payload.decode(), msg.topic, client)
	
	    client.subscribe(topic)
	    client.on_message = on_message
	
	def publish(client, message):
	    msg = message
	    result = client.publish(pubTopic, msg)
	    # result: [0, 1]
	    status = result[0]
	    if status == 0:
	        print(f"Send `{msg}` to topic `{pubTopic}`")
	    else:
	        print(f"Failed to send message to topic {pubTopic}")
	        
	def ruleCheck(value, topic, client):
	    if topic == "temp":
	        if value > 25:
	            publish(client, ["fan", "open"])
	        else:
	            publish(client, ["fan", "close"])
	        
	    elif topic == "humidity":
	        if value > 30:
	            publish(client, ["dehumidifyer", "open"])
	        else:
	            publish(client, ["dehumidifyer", "close"])
	    elif topic == "co2":
	        if value > 1200:
	            publish(client, ["window", "open"])
	        else:
	            publish(client, ["window", "close"])
	    return
	
	def run():
	    client = connect_mqtt()
	    subscribe(client, topic1)
	    subscribe(client, topic2)
	    subscribe(client, topic3)
	    client.loop_forever()
	    
	
	
	if __name__ == '__main__':
	    run()
	'''
	
	
	
	def compilePeripheral(Model model)'''
	from paho.mqtt import client as mqtt_client
	
	broker = 'localhost'
	port = 1883
	topic1 = "temp"
	topic2 = "humidity"
	topic3 = "co2"
	pubTopic = "actuators"
	client_id = 'python-mqtt-rulechecker'
	username = 'my_user'
	password = 'bendevictor'
	
	def connect_mqtt() -> mqtt_client:
	    def on_connect(client, userdata, flags, rc):
	        if rc == 0:
	            print("Connected to MQTT Broker!")
	        else:
	            print("Failed to connect, return code %d\n", rc)
	
	    client = mqtt_client.Client(client_id)
	    client.username_pw_set(username, password)
	    client.on_connect = on_connect
	    client.connect(broker, port)
	    return client
	
	def subscribe(client: mqtt_client, topic):
	    def on_message(client, userdata, msg):
	        print(f"Received `{msg.payload.decode()}` from `{msg.topic}` topic")
	        ruleCheck(msg.payload.decode(), msg.topic, client)
	
	    client.subscribe(topic)
	    client.on_message = on_message
	
	def publish(client, message):
	    msg = message
	    result = client.publish(pubTopic, msg)
	    # result: [0, 1]
	    status = result[0]
	    if status == 0:
	        print(f"Send `{msg}` to topic `{pubTopic}`")
	    else:
	        print(f"Failed to send message to topic {pubTopic}")
	        
	def ruleCheck(value, topic, client):
	    if topic == "temp":
	        if value > 25:
	            publish(client, ["fan", "open"])
	        else:
	            publish(client, ["fan", "close"])
	        
	    elif topic == "humidity":
	        if value > 30:
	            publish(client, ["dehumidifyer", "open"])
	        else:
	            publish(client, ["dehumidifyer", "close"])
	    elif topic == "co2":
	        if value > 1200:
	            publish(client, ["window", "open"])
	        else:
	            publish(client, ["window", "close"])
	    return
	
	def run():
	    client = connect_mqtt()
	    subscribe(client, topic1)
	    subscribe(client, topic2)
	    subscribe(client, topic3)
	    client.loop_forever()
	    
	
	
	if __name__ == '__main__':
	    run()
	'''
	
	def getAllClocks(Model model){
		val root = EcoreUtil2.getRootContainer(model);
        val allSettingSensors = EcoreUtil2.getAllContentsOfType(root, SettingSensor)
    	val allSettingActuators = EcoreUtil2.getAllContentsOfType(root, SettingActuator)
    	
    	'''
    	«FOR settingSensor : allSettingSensors»
    		clock «settingSensor.name»Clock;
    	«ENDFOR»
    	«FOR settingActuator : allSettingActuators»
    		clock «settingActuator.name»Clock;
    	«ENDFOR»
    	'''
	}
	
	def getAllVariables(Model model){
		val root = EcoreUtil2.getRootContainer(model);
        val allRowSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor)
    	val allGreenhouseSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor)
    	
    	'''
    	«FOR rowRules : allRowSensors»
    		int «rowRules.variable.name» := 0;
    	«ENDFOR»
    	
    	«FOR greenhouseRules : allGreenhouseSensors»
    	    int «greenhouseRules.variable.name» := 0;
    	«ENDFOR»
    	'''
    }	
		
	
	def getTopics(Model model){
		val root = EcoreUtil2.getRootContainer(model);
        val allSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor).filter[it.controller.name == controller.name]
        val allGlobalSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor).filter[it.controller.name == controller.name]
        return '''

        «IF !allSensors.empty»
        «FOR sensor: allSensors»
        chan «(sensor.eContainer.eContainer as Greenhouse).name»_«(sensor.eContainer as Row).name»_«sensor.name»;
        «ENDFOR»
        «ENDIF»
        «IF !allGlobalSensors.empty»
        «FOR sensor: allGlobalSensors»
        chan «(sensor.eContainer as Greenhouse).name»_«sensor.name»;
        «ENDFOR»
        «ENDIF»
        '''
		
	}
	
	def getAllActuators(Model model){
        val root = EcoreUtil2.getRootContainer(model);
        val allRowActuators = EcoreUtil2.getAllContentsOfType(root, RowActuator);
        val allGreenhouseActuators = EcoreUtil2.getAllContentsOfType(root, GreenhouseActuator)
        val allGreenhouseSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor);
		val allRowSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor);
        val allRowRules = EcoreUtil2.getAllContentsOfType(root, RowRuleSet);
        val allGreenhouseRules = EcoreUtil2.getAllContentsOfType(root, GreenhouseRuleSet);
        val allSettingActuator = EcoreUtil2.getAllContentsOfType(root, SettingActuator);
        

        
        return '''

        «IF !allRowActuators.isEmpty»
        	«FOR rowActuator : allRowActuators SEPARATOR '\n'»
        		process «rowActuator.name.toUpperCase»(){
        		state
        			«FOR action : rowActuator.action SEPARATOR ',\n'»«action.name»«ENDFOR»;
        		init
        			idle;
        		«IF allRowRules.filter[it.actuator.name == rowActuator.name].size > 0»
				trans
					«FOR action1 : rowActuator.action SEPARATOR ','»«FOR action2 : rowActuator.action»«IF action1.name.contains('idle') && action1.name != action2.name»«action1.name» -> «action2.name»«FOR sensor : allRowSensors»«IF !allRowRules.filter[it.actuator.name ==rowActuator.name].empty»{sync «(sensor.eContainer.eContainer as Greenhouse).name»_«(sensor.eContainer as Row).name»_«sensor.name»?;«FOR settingActuator : allSettingActuator»«IF settingActuator.name == rowActuator.type.name» assign «settingActuator.name»Clock:=0;«ENDIF»«ENDFOR»},«ENDIF»«ENDFOR»
					«ENDIF»
					«IF action1.name != action2.name»«action2.name» -> «action1.name»{}«ENDIF»«ENDFOR»«ENDFOR»;
				«ENDIF»
        		}
        	«ENDFOR»
        «ENDIF»
        
        «IF !allGreenhouseActuators.isEmpty»
           «FOR greenhouseActuator : allGreenhouseActuators SEPARATOR '\n'»
                process «greenhouseActuator.name.toUpperCase»(){
                state
                    «FOR action : greenhouseActuator.action SEPARATOR ',\n'»«action.name»«ENDFOR»;
                init
                    idle;
                «IF allGreenhouseRules.filter[it.actuator.name == greenhouseActuator.name].size > 0»
                trans
					«FOR action1 : greenhouseActuator.action SEPARATOR ','»«FOR action2 : greenhouseActuator.action»«IF action1.name.contains('idle') && action1.name != action2.name»«action1.name» -> «action2.name»«FOR sensor : allRowSensors»«IF !allRowRules.filter[it.actuator.name ==greenhouseActuator.name].empty»{sync «(sensor.eContainer.eContainer as Greenhouse).name»_«(sensor.eContainer as Row).name»_«sensor.name»?;«FOR settingActuator : allSettingActuator»«IF settingActuator.name == greenhouseActuator.type.name» assign «settingActuator.name»Clock:=0;«ENDIF»«ENDFOR»},«ENDIF»«ENDFOR»
					«ENDIF»
					«IF action1.name != action2.name»«action2.name» -> «action1.name»{}«ENDIF»«ENDFOR»«ENDFOR»;
				«ENDIF»
                }
           «ENDFOR»
        «ENDIF»
        
        '''
    }
    
    def getAllSensors(Model model){
    	val root = EcoreUtil2.getRootContainer(model);
        val allRowSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor);
        val allGreenhouseSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor);
        val allRowRules = EcoreUtil2.getAllContentsOfType(root, RowRuleSet);
        val allGreenhouseRules = EcoreUtil2.getAllContentsOfType(root, GreenhouseRuleSet);
        val allSettingSensors = EcoreUtil2.getAllContentsOfType(root, SettingSensor);
        
        return '''

        «IF !allRowSensors.isEmpty»
        	«FOR rowSensor : allRowSensors SEPARATOR '\n'»
        		process «rowSensor.name.toUpperCase»(){
        		state
        			«FOR state : rowSensor.states SEPARATOR ',\n'»«state.name»«IF state.threshold !== null»{«rowSensor.variable.name» «state.op» «state.threshold.computeExpression»}«ENDIF»«ENDFOR»;
        		init
        			optimal;
                «IF allRowRules.filter[it.sensor.name == rowSensor.name].size > 0»
        		trans
        			«FOR rowRule : allRowRules SEPARATOR ','»«FOR state : rowSensor.states»«IF state.name.contains('optimal')»«state.name» -> «rowRule.state.name»«FOR sensor : allRowSensors»«IF sensor.name == rowSensor.name && rowRule.sensor.name == sensor.name»{sync «(sensor.eContainer.eContainer as Greenhouse).name»_«(sensor.eContainer as Row).name»_«sensor.name»!;«FOR settingSensor : allSettingSensors»«IF settingSensor.name == sensor.type.name» assign «settingSensor.name»Clock:=0;«ENDIF»«ENDFOR»}«ENDIF»,
        			«ENDFOR»«rowRule.state.name» -> «state.name»{}«ENDIF»«ENDFOR»«ENDFOR»;
        		«ENDIF»
        		}
        	«ENDFOR»
        «ENDIF»
        
        «IF !allGreenhouseSensors.isEmpty»
           «FOR greenhouseSensor : allGreenhouseSensors SEPARATOR '\n'»
                process «greenhouseSensor.name.toUpperCase»(){
                state
                    «FOR state : greenhouseSensor.states SEPARATOR ',\n'»«state.name»«IF state.threshold !== null»{«greenhouseSensor.variable.name»«state.op»«state.threshold.computeExpression»}«ENDIF»«ENDFOR»;
                init
                    «greenhouseSensor.states.get(0).name»;
                «IF allGreenhouseRules.filter[it.sensor.name == greenhouseSensor.name].size > 0»
                trans
                	«FOR greenhouseRule : allGreenhouseRules SEPARATOR ','»«FOR state : greenhouseSensor.states»«IF state.name.contains('optimal')»
        			«state.name» -> «greenhouseRule.state.name»
        			«FOR sensor : allRowSensors»
        			«IF sensor.name == greenhouseSensor.name»
        			«IF greenhouseRule.sensor.name == sensor.name»{sync «(sensor.eContainer.eContainer as Greenhouse).name»_«(sensor.eContainer as Row).name»_«sensor.name»!;«FOR settingSensor : allSettingSensors»«IF settingSensor.name == sensor.type.name» assign «settingSensor.name»Clock:=0;«ENDIF»«ENDFOR»}«ENDIF»,
        			«ENDIF»
        			«ENDFOR»«greenhouseRule.state.name» -> «state.name»{}«ENDIF»«ENDFOR»«ENDFOR»;
                «ENDIF»
                }
           	«ENDFOR»
        «ENDIF»
        
        '''
    }
    
    def instantiateVerificationModels(Model model){
    	val root = EcoreUtil2.getRootContainer(model);
        val allRowSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor);
        val allGreenhouseSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor)
        val allRowActuators = EcoreUtil2.getAllContentsOfType(root, RowActuator);
        val allGreenhouseActuators = EcoreUtil2.getAllContentsOfType(root, GreenhouseActuator)
    	
    	'''
    	«IF !allRowSensors.isEmpty»
    	    «FOR rowSensor : allRowSensors»
    	    «rowSensor.name.toLowerCase» := «rowSensor.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	«IF !allGreenhouseSensors.isEmpty»
    	    «FOR greenhouseSensor : allGreenhouseSensors»
    	    «greenhouseSensor.name.toLowerCase» := «greenhouseSensor.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	«IF !allRowActuators.isEmpty»
    	    «FOR rowActuators : allRowActuators»
    	    «rowActuators.name.toLowerCase» := «rowActuators.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	«IF !allGreenhouseActuators.isEmpty»
    	    «FOR greenhouseActuators : allGreenhouseActuators»
    	    «greenhouseActuators.name.toLowerCase» := «greenhouseActuators.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	system «IF !allRowSensors.isEmpty»«FOR rowSensor : allRowSensors SEPARATOR ', '»«rowSensor.name.toLowerCase»«ENDFOR»«ENDIF», «IF !allGreenhouseSensors.isEmpty»«FOR greenhouseSensor : allGreenhouseSensors SEPARATOR ', '»«greenhouseSensor.name.toLowerCase»«ENDFOR»«ENDIF», «IF !allRowActuators.isEmpty»«FOR rowActuators : allRowActuators SEPARATOR ', '»«rowActuators.name.toLowerCase»«ENDFOR»«ENDIF», «IF !allGreenhouseActuators.isEmpty»«FOR greenhouseActuators : allGreenhouseActuators SEPARATOR ', '»«greenhouseActuators.name.toLowerCase»«ENDFOR»«ENDIF»;
    	'''
    }
    
    
	
	
	
	def compileVerification(Model model)
	'''
	«model.getAllClocks»
	«model.getAllVariables»
	«model.getTopics»
	«model.getAllActuators»
	«model.getAllSensors»
	«model.instantiateVerificationModels»
	'''
	
	def static dispatch String computeExpression(MathNumber exp) {
        exp.value.toString
    }

    def static dispatch String computeExpression(Plus exp) {
        "(" + exp.left.computeExpression + "+" + exp.right.computeExpression + ")"
    }

    def static dispatch String computeExpression(Minus exp) {
        "(" + exp.left.computeExpression + "-" + exp.right.computeExpression + ")"
    }

    def static dispatch String computeExpression(Mult exp) {
        "(" + exp.left.computeExpression + "*" + exp.right.computeExpression + ")"
    }

    def static dispatch String computeExpression(Div exp) {
        "(" + exp.left.computeExpression + "/" + exp.right.computeExpression + ")"
    }
}
