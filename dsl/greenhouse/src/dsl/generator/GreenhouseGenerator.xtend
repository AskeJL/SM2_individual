/*
 * generated by Xtext 2.25.0
 */
package dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dsl.greenhouse.Model
import org.eclipse.xtext.EcoreUtil2
import dsl.greenhouse.RowSensor
import dsl.greenhouse.RowActuator
import dsl.greenhouse.GreenhouseActuator
import dsl.greenhouse.State
import dsl.greenhouse.Action
import dsl.greenhouse.GreenhouseSensor
import dsl.greenhouse.Greenhouse
import dsl.greenhouse.Row
import dsl.greenhouse.GreenhouseRuleSet
import dsl.greenhouse.RowRuleSet
import dsl.greenhouse.MathNumber
import dsl.greenhouse.Plus
import dsl.greenhouse.Minus
import dsl.greenhouse.Mult
import dsl.greenhouse.Div

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GreenhouseGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val model = resource.allContents.filter(Model).next
		fsa.generateFile('controller/' + model.name + ".py", model.compileController)
		fsa.generateFile('peripheral/' + model.name + ".java", model.compilePeripheral)
		fsa.generateFile('verification/' + model.name + ".xta", model.compileVerification)
		
	}
	
	def compileController(Model model){
	val root = EcoreUtil2.getRootContainer(model);
    val allRowSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor);
    val allGreenhouseSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor)
    val allRowRuleset = EcoreUtil2.getAllContentsOfType(root, RowRuleSet)
    val allGreenhouseRuleset = EcoreUtil2.getAllContentsOfType(root, GreenhouseRuleSet)
    '''
	from paho.mqtt import client as mqtt_client
	class Sensor:
	    currentState = ""
	    def __init__(self, name, states, variable, actuator):
	        self.name = name
	        self.states = states
	        self.variable = variable
	        self.actuator = actuator
	    def updateSensor(self, variable, client):
	        self.variable = variable
	        ruleCheck(variable, self, client, self.states)
	    def updateSensorState(self, state, client):
	        theKey = next(iter(state))
	        self.currentState = theKey
	        publish(client, self.actuator, state.get(self.currentState))
	
	broker = 'localhost'
	port = 1883
	client_id = 'python-mqtt-controller'
	username = 'my_user'
	password = 'bendevictor'
	manual = 0
	sensors = []
	def connect_mqtt() -> mqtt_client:
	    def on_connect(client, userdata, flags, rc):
	        if rc == 0:
	            print("Connected to MQTT Broker!")
	        else:
	            print("Failed to connect, return code %d\n", rc)
	
	    client = mqtt_client.Client(client_id)
	    client.username_pw_set(username, password)
	    client.on_connect = on_connect
	    client.connect(broker, port)
	    return client
	
	
	def subscribe(client: mqtt_client, sensor):
	    def on_message(client, userdata, msg):
	        print(f"Received `{msg.payload.decode()}` from `{msg.topic}` topic")
	        for s in sensors:
	            if s.name == msg.topic:
	                s.updateSensor(msg.payload.decode(), client)
	        #ruleCheck(msg.payload.decode(), msg.topic, client)
	    client.subscribe(sensor.name)
	    client.on_message = on_message
	
	def publish(client,topic, message):
	    msg = message
	    if manual == 0:
	        result = client.publish(topic, msg)
	        # result: [0, 1]
	        status = result[0]
	        if status == 0:
	            print(f"Send `{msg}` to topic `{topic}`")
	        else:
	            print(f"Failed to send message to topic {topic}")
	    
	
	def ruleCheck(value, sensor, client,states):
	    if sensor.name == "manual":
	        global manual 
	        manual = int(value)
		«FOR sensor : allRowSensors»
		if sensor.name == "«(sensor.eContainer.eContainer as Greenhouse).name»/«(sensor.eContainer as Row).name»/«sensor.name»":
			«FOR state : sensor.states»
			if float(value) «state.op» «state.threshold.computeExpression()»:
				sensor.updateSensorState(states[«sensor.states.indexOf(state)»],client)
			«ENDFOR»
		«ENDFOR»
		«FOR sensor : allGreenhouseSensors»
		if sensor.name == "«(sensor.eContainer as Greenhouse).name»/«sensor.name»":
			«FOR state : sensor.states»
			if float(value) «state.op» «state.threshold.computeExpression()»:
				sensor.updateSensorState(states[«sensor.states.indexOf(state)»],client)
			«ENDFOR»
		«ENDFOR»
	    return
	
	def run():
	    client = connect_mqtt()
	    manualState = Sensor("manual", None, 0, None)
	    sensors.append(manualState)
	    «FOR sensor : allRowSensors»
	    sr«allRowSensors.indexOf(sensor)» = Sensor("«(sensor.eContainer.eContainer as Greenhouse).name»/«(sensor.eContainer as Row).name»/«sensor.name»",[«FOR state : sensor.states»{"«state.name»":"«FOR rule : allRowRuleset»«IF rule.sensor.name == sensor.name && rule.state.name == state.name»«rule.trigger.name»«ENDIF»«ENDFOR»"},«ENDFOR»],0,"«(sensor.eContainer.eContainer as Greenhouse).name»/«(sensor.eContainer as Row).name»/«getRowActuatorName(model, sensor)»")
	    sensors.append(sr«allRowSensors.indexOf(sensor)»)
	    subscribe(client, sr«allRowSensors.indexOf(sensor)»)
	    «ENDFOR»
	    «FOR sensor : allGreenhouseSensors»
	    sg«allGreenhouseSensors.indexOf(sensor)» = Sensor("«(sensor.eContainer as Greenhouse).name»/«sensor.name»",[«FOR state : sensor.states»{"«state.name»":"«FOR rule : allGreenhouseRuleset»«IF rule.sensor.name == sensor.name && rule.state.name == state.name»«rule.action.name»«ENDIF»«ENDFOR»"},«ENDFOR»],0,"«(sensor.eContainer as Greenhouse).name»/«getGreenhouseActuatorName(model, sensor)»")
	    sensors.append(sg«allGreenhouseSensors.indexOf(sensor)»)
	    subscribe(client, sg«allGreenhouseSensors.indexOf(sensor)»)
	    «ENDFOR»
	    client.loop_forever()
	
	if __name__ == '__main__':
	    run()
	'''
	}
	
	def getRowActuatorName(Model model, RowSensor sensor){
		val root = EcoreUtil2.getRootContainer(model);
		val allRowRuleset = EcoreUtil2.getAllContentsOfType(root, RowRuleSet);
    	for (rule : allRowRuleset){
    		if(rule.sensor.name == sensor.name){
    			return '''«rule.actuator.name»'''
    		}
    	}
		return ''''''
	}
	def getGreenhouseActuatorName(Model model, GreenhouseSensor sensor){
		val root = EcoreUtil2.getRootContainer(model);
    	val allGreenhouseRuleset = EcoreUtil2.getAllContentsOfType(root, GreenhouseRuleSet);
    	for (rule : allGreenhouseRuleset){
    		if(rule.sensor.name == sensor.name){
    			return '''«rule.actuator.name»'''
    		}
    	}
		return ''''''
	}
	
	def compilePeripheral(Model model)'''
	from paho.mqtt import client as mqtt_client
	class Sensor:
	    currentState = ""
	    def __init__(self, name, states, variable, actuator):
	        self.name = name
	        self.states = states
	        self.variable = variable
	        self.actuator = actuator
	    def updateSensor(self, variable, client):
	        self.variable = variable
	        ruleCheck(variable, self, client, self.states)
	    def updateSensorState(self, state, client):
	        theKey = next(iter(state))
	        self.currentState = theKey
	        publish(client, self.actuator, state.get(self.currentState))
	
	broker = 'localhost'
	port = 1883
	topic1 = "temp"
	topic2 = "humidity"
	topic3 = "co2"
	topic4 = "moisture"
	client_id = 'python-mqtt-rulechecker'
	username = 'my_user'
	password = 'bendevictor'
	manual = 0
	sensors = []
	def connect_mqtt() -> mqtt_client:
	    def on_connect(client, userdata, flags, rc):
	        if rc == 0:
	            print("Connected to MQTT Broker!")
	        else:
	            print("Failed to connect, return code %d\n", rc)
	
	    client = mqtt_client.Client(client_id)
	    client.username_pw_set(username, password)
	    client.on_connect = on_connect
	    client.connect(broker, port)
	    return client
	
	
	def subscribe(client: mqtt_client, sensor):
	    def on_message(client, userdata, msg):
	        print(f"Received `{msg.payload.decode()}` from `{msg.topic}` topic")
	        for s in sensors:
	            if s.name == msg.topic:
	                s.updateSensor(msg.payload.decode(), client)
	        #ruleCheck(msg.payload.decode(), msg.topic, client)
	    client.subscribe(sensor.name)
	    client.on_message = on_message
	
	def publish(client,topic, message):
	    msg = message
	    if manual == 0:
	        result = client.publish(topic, msg)
	        # result: [0, 1]
	        status = result[0]
	        if status == 0:
	            print(f"Send `{msg}` to topic `{topic}`")
	        else:
	            print(f"Failed to send message to topic {topic}")
	    
	
	def ruleCheck(value, sensor, client,states):
	    if sensor.name == "manual":
	        global manual 
	        manual = int(value)
	    if sensor.name == "greenify/tomatoes/moistSensor":
	        if float(value)  > 1000:
	            sensor.updateSensorState(states[0],client)
	        elif float(value) > 500 and float(value) < 1000:
	            sensor.updateSensorState(states[1],client)
	        elif float(value)  < 500:
	            sensor.updateSensorState(states[2],client)
	    if sensor.name == "greenify/tempSensor":
	        if float(value)  > 40:
	            sensor.updateSensorState(states[0],client)
	        elif float(value) > 25 and float(value) < 40:
	            sensor.updateSensorState(states[1],client)
	        elif float(value)  < 25:
	            sensor.updateSensorState(states[2],client)
	    return
	
	def run():
	    client = connect_mqtt()
	    manualState = Sensor("manual", None, 0, None)
	    t1 = Sensor("greenify/tomatoes/moistSensor", [{"moist":"stop"}, {"optimal":"stop"}, {"dry":"start"}], 0, "greenify/tomatoes/pump")
	    t2 = Sensor("greenify/tempSensor", [{"hot":"max"}, {"optimal":"min"}, {"cold":"stop"}], 0, "greenify/fan")
	    sensors.append(manualState)
	    sensors.append(t1)
	    sensors.append(t2)
	    subscribe(client, t1)
	    subscribe(client, t2)
	    subscribe(client, manualState)
	    client.loop_forever()
	
	if __name__ == '__main__':
	    run()
	'''
	
	def getTopics(Model model){
		val root = EcoreUtil2.getRootContainer(model);
        val allSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor).filter[it.controller.name == controller.name]
        val allGlobalSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor).filter[it.controller.name == controller.name]
        return '''

        «IF !allSensors.empty»
        «FOR sensor: allSensors»
        chan «(sensor.eContainer.eContainer as Greenhouse).name»_«(sensor.eContainer as Row).name»_«sensor.name»;
        «ENDFOR»
        «ENDIF»
        «IF !allGlobalSensors.empty»
        «FOR sensor: allGlobalSensors»
        chan «(sensor.eContainer as Greenhouse).name»_«sensor.name»;
        «ENDFOR»
        «ENDIF»
        '''
		
	}
	
	def getAllActuators(Model model){
        val root = EcoreUtil2.getRootContainer(model);
        val allRowActuators = EcoreUtil2.getAllContentsOfType(root, RowActuator);
        val allGreenhouseActuators = EcoreUtil2.getAllContentsOfType(root, GreenhouseActuator)
       
        
        return '''

        «IF !allRowActuators.isEmpty»
        	«FOR rowActuator : allRowActuators SEPARATOR '\n'»
        		process «rowActuator.name.toUpperCase»(){
        		state
        			«FOR action : rowActuator.action SEPARATOR ',\n'»«action.name»«ENDFOR»;
        		init
        			«rowActuator.action.get(0).name»;
        		trans
        			«FOR action1 : rowActuator.action SEPARATOR ',\n'»«FOR action2 : rowActuator.action SEPARATOR ',\n'»«action1.name» -> «action2.name»{}«ENDFOR»«ENDFOR»;
        		}
        	«ENDFOR»
        «ENDIF»
        
        «IF !allGreenhouseActuators.isEmpty»
           «FOR greenhouseActuator : allGreenhouseActuators SEPARATOR '\n'»
                process «greenhouseActuator.name.toUpperCase»(){
                state
                    «FOR action : greenhouseActuator.action SEPARATOR ',\n'»«action.name»«ENDFOR»;
                init
                    «greenhouseActuator.action.get(0).name»;
                trans
                	«FOR action1 : greenhouseActuator.action SEPARATOR ',\n'»«FOR action2 : greenhouseActuator.action SEPARATOR ',\n'»«action1.name» -> «action2.name»{}«ENDFOR»«ENDFOR»;
                }
           «ENDFOR»
        «ENDIF»
        
        '''
    }
    
    def getAllSensors(Model model){
    	val root = EcoreUtil2.getRootContainer(model);
        val allRowSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor);
        val allGreenhouseSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor)
        
        return '''

        «IF !allRowSensors.isEmpty»
        	«FOR rowSensor : allRowSensors SEPARATOR '\n'»
        		process «rowSensor.name.toUpperCase»(){
        		state
        			«FOR state : rowSensor.states SEPARATOR ',\n'»«state.name»«ENDFOR»;
        		init
        			«rowSensor.states.get(0).name»;
        		trans
        			«FOR state1 : rowSensor.states SEPARATOR ',\n'»«FOR state2 : rowSensor.states SEPARATOR ',\n'»«state1.name» -> «state2.name»{}«ENDFOR»«ENDFOR»;
        		}
        	«ENDFOR»
        «ENDIF»
        
        «IF !allGreenhouseSensors.isEmpty»
           «FOR greenhouseSensor : allGreenhouseSensors SEPARATOR '\n'»
                process «greenhouseSensor.name.toUpperCase»(){
                state
                    «FOR state : greenhouseSensor.states SEPARATOR ',\n'»«state.name»«ENDFOR»;
                init
                    «greenhouseSensor.states.get(0).name»;
                trans
                	«FOR state1 : greenhouseSensor.states SEPARATOR ',\n'»«FOR state2 : greenhouseSensor.states SEPARATOR ',\n'»«state1.name» -> «state2.name»{}«ENDFOR»«ENDFOR»;
                }
           «ENDFOR»
        «ENDIF»
        
        '''
    }
    
    def instantiateVerificationModels(Model model){
    	val root = EcoreUtil2.getRootContainer(model);
        val allRowSensors = EcoreUtil2.getAllContentsOfType(root, RowSensor);
        val allGreenhouseSensors = EcoreUtil2.getAllContentsOfType(root, GreenhouseSensor)
        val allRowActuators = EcoreUtil2.getAllContentsOfType(root, RowActuator);
        val allGreenhouseActuators = EcoreUtil2.getAllContentsOfType(root, GreenhouseActuator)
    	
    	'''
    	«IF !allRowSensors.isEmpty»
    	    «FOR rowSensor : allRowSensors»
    	    «rowSensor.name.toLowerCase» := «rowSensor.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	«IF !allGreenhouseSensors.isEmpty»
    	    «FOR greenhouseSensor : allGreenhouseSensors»
    	    «greenhouseSensor.name.toLowerCase» := «greenhouseSensor.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	«IF !allRowActuators.isEmpty»
    	    «FOR rowActuators : allRowActuators»
    	    «rowActuators.name.toLowerCase» := «rowActuators.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	«IF !allGreenhouseActuators.isEmpty»
    	    «FOR greenhouseActuators : allGreenhouseActuators»
    	    «greenhouseActuators.name.toLowerCase» := «greenhouseActuators.name.toUpperCase»();
    	    «ENDFOR»
    	«ENDIF»
    	
    	system «IF !allRowSensors.isEmpty»«FOR rowSensor : allRowSensors SEPARATOR ', '»«rowSensor.name.toLowerCase»«ENDFOR»«ENDIF», «IF !allGreenhouseSensors.isEmpty»«FOR greenhouseSensor : allGreenhouseSensors SEPARATOR ', '»«greenhouseSensor.name.toLowerCase»«ENDFOR»«ENDIF», «IF !allRowActuators.isEmpty»«FOR rowActuators : allRowActuators SEPARATOR ', '»«rowActuators.name.toLowerCase»«ENDFOR»«ENDIF», «IF !allGreenhouseActuators.isEmpty»«FOR greenhouseActuators : allGreenhouseActuators SEPARATOR ', '»«greenhouseActuators.name.toLowerCase»«ENDFOR»«ENDIF»;
    	'''
    }
	
	
	
	def compileVerification(Model model){
	'''
	«model.getTopics»
	«model.getAllActuators»
	«model.getAllSensors»
	«model.instantiateVerificationModels»
	'''}
	
	def static dispatch String computeExpression(MathNumber exp) {
        exp.value.toString
    }

    def static dispatch String computeExpression(Plus exp) {
        "(" + exp.left.computeExpression + "+" + exp.right.computeExpression + ")"
    }

    def static dispatch String computeExpression(Minus exp) {
        "(" + exp.left.computeExpression + "-" + exp.right.computeExpression + ")"
    }

    def static dispatch String computeExpression(Mult exp) {
        "(" + exp.left.computeExpression + "*" + exp.right.computeExpression + ")"
    }

    def static dispatch String computeExpression(Div exp) {
        "(" + exp.left.computeExpression + "/" + exp.right.computeExpression + ")"
    }
}
